---
title: Java核心技术——对象基础
date: 2019-06-07 20:54:51
tags: [Java，读书笔记]
categories: 核心技术读书笔记
---
1. `System`类对象调用`initializeSystemClass()`进行各成员对象的初始化，并且可以通过调用`setOut()`等方法对输入流、输出流对象进行切换，但流对象却是用`final`修饰的，原因在于`setOut()`等方法实际调用的是`native`关键词修饰的`setOut0()`方法。

2. `Java`中的`String`字符串拼接，其本质如下，可以通过查看字节码实现：

   ```java
   //new StringBuilder() -> append() -> toString()
   String string= "1" + new String("2");
   //new StringBuilder() -> valueOf() -> append() -> toString()
   String a = "123";
   String b = "456";
   String string = a + b;
   ```

3. `Java`中的`String`之所以被设计为不可变类，是为了实现共享，保证线程安全。不可变类有以下特点：

   ```java
   1. 将类声明为final，所以它不能被继承（不能通过自定义子类来修改父类属性）
   2. 将所有的成员声明为私有的，这样就不允许直接访问这些成员
   3. 对变量不要提供setter方法
   4. 将所有可变的成员声明为final，这样只能对它们赋值一次
   5. 通过构造器初始化所有成员，进行深拷贝(deep copy)（执行构造函数后，不会因为形参本身发生变化而影响对象的变量）
   6. 在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝（不能通过get方法获取对象后在外部进行修改）
   ```

4. 在`for`循环中，不能通过两个浮点数的`！=`比较作为终止条件，很有可能造成死循环。

5. 数组拷贝的效率从快到慢排序：`System.arrayCopy() > Arrays.copyOf() > Object.clone() > for`循环，其中前两种为浅拷贝，第三种对于数组除外的对象是深拷贝。

6. `get`方法不能返回带有`set`方法的对象，这样的话修改了`get`返回值的对象会直接对原始对象的值进行更改，**如果需要返回对象并且不影响原始对象中的值，则应该先进行`clone`，或者使用不可变类**。（`P110`）

7. 对于类中辅助方法，可以将其设置为`private`，不允许其他类进行访问；同时对于`private`方法，只要保证类内部没有调用该方法，就可以将其删去，因为不会有外部类调用该方法。

8. 对于`final`修饰的域，必须在定义域时进行赋值，或者在构造函数中进行赋值，即不会设置默认值。

9. 对于`final`修饰的对象，只能保证改变量不能指向其他对象，但是不能保证对象的值不能被改变。（`P112`）

10. 类的静态成员变量是存储在方法区中的，如果静态成员为对象，则变量在方法区中，引用的对象在堆中。

11. 静态方法不能访问具体对象的实例域，但是在静态方法中新建一个对象，再进行对象操作也是可以的。

12. `Java`方法的总结：①方法不能修改一个基本数据类型的变量②方法可以改变一个对象变量的状态③方法不能让对象变量引用一个新的对象。（`P120`）

13. 重载：多个方法具有相同的名字，不同的参数；方法名、参数的类型和数量构成方法的签名（不包括返回值类型）。

14. 如果类中定义了构造器，且没有定义无参构造器，则调用无参构造器为非法；因为只有在没有定义构造器的情况下，系统才会提高一个默认的无参构造器。（`P124`）

15. 在构造函数中调用其他构造函数，用this即可；创建对象时的初始化顺序：成员变量声明、初始化块、构造函数，前面两个的先后顺序看那个先出现。

16. 对象初始化过程：①所有成员变量赋默认值②根据成员变量和初始化块的出现顺序依次进行初始化③构造函数初始化

17. 文件流等系统资源，即使`JVM`停止运行也不会被回收，所以需要手动调用`close()`进行资源回收。

18. 静态导入，将某个类中的静态方法和静态成员变量导入到类中，使用时不再需要加上类名。

19. `Java`编译器总是会在当前的目录中查找文件，但`Java`虚拟机仅在类路径中包含`"."`时才会扫描当前路径，如果忘了配置`"."`，有可能出现编译通过，但不能运行的情况。

20. 类的设计技巧，有以下几种：

    ```
    1. 一定要保证数据私有
    2. 一定要对数据初始化
    3. 不要在类中使用过多的基本类型
    4. 不是所有的域都需要独立的域访问器和域更改器
    5. 将职责过多的类进行分解
    6. 类名和方法名要能够体现他们的职责
    7. 优先使用不可变的类
    ```
